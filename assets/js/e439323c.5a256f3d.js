"use strict";(self.webpackChunkrushjs_io=self.webpackChunkrushjs_io||[]).push([[4794],{158:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(6393);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),h=i,m=c["".concat(s,".").concat(h)]||c[h]||d[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6550:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var a=n(9122),i=n(2501),r=(n(6393),n(158)),o=["components"],l={title:"Cobuilds (experimental)"},s=void 0,u={unversionedId:"pages/maintainer/cobuilds",id:"pages/maintainer/cobuilds",title:"Cobuilds (experimental)",description:"\x3c!--",source:"@site/docs/pages/maintainer/cobuilds.md",sourceDirName:"pages/maintainer",slug:"/pages/maintainer/cobuilds",permalink:"/pages/maintainer/cobuilds",draft:!1,editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/rushjs.io/docs/pages/maintainer/cobuilds.md",tags:[],version:"current",frontMatter:{title:"Cobuilds (experimental)"},sidebar:"docsSidebar",previous:{title:"Enabling phased builds",permalink:"/pages/maintainer/phased_builds"},next:{title:"NPM registry authentication",permalink:"/pages/maintainer/npm_registry_auth"}},p={},c=[{value:"When to use cobuilds?",id:"when-to-use-cobuilds",level:2},{value:"Enabling the cobuild feature",id:"enabling-the-cobuild-feature",level:2},{value:"Configuring build pipelines",id:"configuring-build-pipelines",level:2},{value:"Cobuild environment variables in detail",id:"cobuild-environment-variables-in-detail",level:2},{value:"<code>RUSH_COBUILD_CONTEXT_ID</code>",id:"rush_cobuild_context_id",level:3},{value:"<code>RUSH_COBUILD_RUNNER_ID</code>",id:"rush_cobuild_runner_id",level:3},{value:"Technical details",id:"technical-details",level:2},{value:"Build cache correctness",id:"build-cache-correctness",level:3},{value:"What gets stored in Redis?",id:"what-gets-stored-in-redis",level:3},{value:"See also",id:"see-also",level:2}],d={toc:c},h="wrapper";function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rush's \"cobuild\" feature (cooperative builds) provides a lightweight solution for distributing work across\nmultiple machines. The idea is a simple extension of what you're already doing: just spawn multiple instances\nof the same CI pipeline on different machines, allowing them to share work via Rush's ",(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/build_cache"},"build cache"),"."),(0,r.kt)("p",null,"For example, suppose your job runs ",(0,r.kt)("inlineCode",{parentName:"p"},"rush install && rush build"),", and we launch this command on two machines.\nIf machine #1 has already built a project, then machine #2 will skip that project, instead fetching the result\nfrom the build cache. In this way, the building gets divided between the two pipelines, and with perfect parallelism\nthe build might finish in half the time."),(0,r.kt)("p",null,"But there is a flaw in this idea: What if machine #2 reaches a project that machine #1 already started building\nbut has not finished yet? This cache miss will cause machine #2 to start building the same project,\nwhen it may have been better to work on something else while waiting for machine #1 to finish that project.\nWe can solve this by using a simple key/value store to communicate progress between machines.\n(In this tutorial we'll use Rush's ",(0,r.kt)("a",{parentName:"p",href:"https://redis.io/"},"Redis")," provider, but if your company already hosts\nsome other service such as ",(0,r.kt)("a",{parentName:"p",href:"https://www.memcached.org/"},"Memcached"),", it's\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/blob/main/rush-plugins/rush-redis-cobuild-plugin/src/RedisCobuildLockProvider.ts"},"fairly easy"),"\nto implement your own provider.)"),(0,r.kt)("h2",{id:"when-to-use-cobuilds"},"When to use cobuilds?"),(0,r.kt)("p",null,'Without cobuilds, Rush already parallelizes your jobs on a single machine. (This may not be immediately obvious,\nsince Rush\'s output is "collated" for readability, making it appear as if projects are getting built one at a time.)\nYou can fine-tune the maximum parallelism using the ',(0,r.kt)("inlineCode",{parentName:"p"},"--parallelism")," command-line parameter, but keep in mind\nthat projects can only build concurrently if they don't depend on each other. Thus, cobuilds will only help\nif you've already reached the limits for a single machine (considering cpu cores, disk I/O rates, and available memory).\nAnd only if further parallelism is actually possible for your monorepo's project dependency graph."),(0,r.kt)("p",null,"The cobuild feature launches multiple instances of a CI pipeline, under the assumption that machines will be\nreadily available. For example, if your cobuild uses 4 machines, and your VM pool has 40 machines, then\ncontention would not become an issue until 10 pull requests are backed up in the queue. In that case, a\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue"},"merge queue"),"\ncan help by optimistically validating multiple PRs together."),(0,r.kt)("p",null,'An extremely large monorepo might need thousands of machines, at which point it would make more\nsense to use a "build accelerator" such as\n',(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/BuildXL/blob/main/Documentation/Wiki/Frontends/js-rush-options.md"},"BuildXL"),"\ninstead of cobuilds. (There are also plans to integrate Rush with\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bazelbuild/bazel-buildfarm"},"bazel-buildfarm"),"; Bazel is Google's equivalent of BuildXL.)\nBuild accelerators generally require you to replace your CI system with their centralized job scheduler\nthat manages its own dedicated pool of machines. Such systems require nontrivial maintenance\nand can have steeper learning curves, so we generally recommend to start with cobuilds first."),(0,r.kt)("p",null,"Before adopting cobuilds, we recommend to try these things first:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Enable the build cache"),": The ",(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/build_cache"},"build cache")," is a prerequisite for cobuilds.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Identify bottlenecks:")," If your monorepo's dependency graph does not actually allow lots of projects\nto be built in parallel, that must be fixed first before considering distributed builds.\nYou can use Rush's ",(0,r.kt)("inlineCode",{parentName:"p"},"--timeline")," parameter to identify bottlenecks that are causing too many projects\nto wait before they can start building. These bottlenecks can be solved by:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"eliminating unnecessary dependencies between projects"),(0,r.kt)("li",{parentName:"ul"},"introducing ",(0,r.kt)("a",{parentName:"li",href:"/pages/maintainer/phased_builds"},"Rush phases")," to break up build steps into multiple operations"),(0,r.kt)("li",{parentName:"ul"},"refactoring code to break up big projects into smaller projects"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Upgrade your hardware:")," If your builds are slow, it can help to add more machines. We generally recommend\nto choose high end hardware with the maximum amount of RAM and CPU cores for your plan, based on typical\nbehavior of ",(0,r.kt)("inlineCode",{parentName:"p"},"rush install")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rush build"),". But every monorepo is different, so collect benchmarks on\ndifferent hardware configurations to inform your decision. Speeding up the build makes everybody more productive;\nhowever, because hardware upgrades usually come from a different budget than engineering salaries,\nmanagement sometimes may need some help to see this connection.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Cache state between runs:")," CI machines often start ",(0,r.kt)("inlineCode",{parentName:"p"},"rush install && rush build")," with a completely clean\nmachine image. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"rush install")," time can be improved by using ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_PNPM_STORE_PATH")," to\nsave the PNPM store and restore it between runs. Some environments permit the machine to be reused for\nmultiple jobs, so that other Rush caches are preserved.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Consider using a merge queue"),": GitHub offers a basic\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue"},"merge queue"),"\nfor free. Rush can also be used with the ",(0,r.kt)("a",{parentName:"p",href:"https://mergify.com/"},"Mergify")," enterprise service."))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Prerequisites")),(0,r.kt)("p",{parentName:"blockquote"},"In order to use this feature, you will need:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Rush ",(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/build_cache"},"build cache")," enabled with a cloud storage provider.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("a",{parentName:"p",href:"https://redis.io/"},"Redis server"),". If your company uses some other key/value service,\nyou can implement a plugin by following the example of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/rushstack/tree/main/rush-plugins/rush-redis-cobuild-plugin"},"rush-redis-cobuild-plugin"),".\n(And consider contributing it back to Rush Stack!)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'A CI system that is able to trigger multiple runners for a given CI pipeline.\nFor example, Jenkins and Azure DevOps allow a "parent" pipeline to trigger "child" pipelines.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/phased_builds"},"Rush phases")," are suggested to increase parallelism, but are ",(0,r.kt)("em",{parentName:"p"},"not required")," for cobuilds.")))),(0,r.kt)("h2",{id:"enabling-the-cobuild-feature"},"Enabling the cobuild feature"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Upgrade ",(0,r.kt)("inlineCode",{parentName:"p"},"rushVersion")," in your ",(0,r.kt)("strong",{parentName:"p"},"rush.json")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"5.104.1")," or newer.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create an autoinstaller for the Rush plugin:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"rush init-autoinstaller --name cobuild-plugin\n")),(0,r.kt)("p",{parentName:"li"},"It's also okay to use an existing autoinstaller. For more about Rush plugins and autoinstallers,\nsee ",(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/using_rush_plugins"},"Using Rush plugins")," and ",(0,r.kt)("a",{parentName:"p",href:"/pages/maintainer/autoinstallers"},"Autoinstallers"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Add the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rushstack/rush-redis-cobuild-plugin")," plugin to the autoinstaller. (We'll use Redis for this tutorial.)"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"common/autoinstallers/cobuild-plugin/package.json")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "name": "cobuild-plugin",\n  "version": "1.0.0",\n  "private": true,\n  "dependencies": {\n    "@rushstack/rush-redis-cobuild-plugin": "5.104.0"\n  }\n}\n')),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"\ud83d\udc49 ",(0,r.kt)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.kt)("p",{parentName:"blockquote"},"Over time, make sure to keep the version of ",(0,r.kt)("inlineCode",{parentName:"p"},"@rushstack/rush-redis-cobuild-plugin")," in sync with\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"rushVersion")," from your ",(0,r.kt)("strong",{parentName:"p"},"rush.json"),"."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the autoinstaller's lockfile:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"rush update-autoinstaller --name cobuild-plugin\n\n# Remember to commit the updated pnpm-lock.yaml file to git\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Next, we need to update ",(0,r.kt)("strong",{parentName:"p"},"rush-plugins.json")," to load the plugin from our ",(0,r.kt)("inlineCode",{parentName:"p"},"rush-plugins")," autoinstaller."),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"common/config/rush/rush-plugins.json")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "$schema": "https://developer.microsoft.com/json-schemas/rush/v5/rush-plugins.schema.json",\n  "plugins": [\n    /**\n     * Each item defines a plugin to be loaded by Rush.\n     */\n    {\n      /**\n       * The name of the NPM package that provides the plugin.\n       */\n      "packageName": "@rushstack/rush-redis-cobuild-plugin",\n\n      /**\n        * The name of the plugin.  This can be found in the "pluginName"\n        * field of the "rush-plugin-manifest.json" file in the NPM package folder.\n        */\n      "pluginName": "rush-redis-cobuild-plugin",\n\n      /**\n       * The name of a Rush autoinstaller that will be used for installation, which\n       * can be created using "rush init-autoinstaller".  Add the plugin\'s NPM package\n       * to the package.json "dependencies" of your autoinstaller, then run\n       * "rush update-autoinstaller".\n       */\n      "autoinstallerName": "cobuild-plugin"\n    }\n  ]\n}\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Configure ",(0,r.kt)("inlineCode",{parentName:"p"},"rush-redis-cobuild-plugin")," by creating its config file:"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"common/config/rush-plugins/rush-redis-cobuild-plugin.json")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  /**\n   * The URL of your Redis server\n   */\n  "url": "redis://server.example.com:6379",\n\n  /**\n   * An environment variable that your CI pipeline will assign,\n   * which the plugin uses to authenticate with Redis.\n   */\n  "passwordEnvironmentVariable": "REDIS_PASSWORD"\n}\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"rush init")," to create the ",(0,r.kt)("strong",{parentName:"p"},"cobuild.json")," ",(0,r.kt)("a",{parentName:"p",href:"/pages/configs/cobuild_json"},"config file")," that is\nused to enable the cobuild feature. Make sure to set ",(0,r.kt)("inlineCode",{parentName:"p"},'"cobuildFeatureEnabled": true')," as shown below:"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"common/config/rush/cobuild.json")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-js"},'/**\n * This configuration file manages Rush\'s cobuild feature.\n * More documentation is available on the Rush website: https://rushjs.io\n */\n {\n  "$schema": "https://developer.microsoft.com/json-schemas/rush/v5/cobuild.schema.json",\n\n  /**\n   * (Required) EXPERIMENTAL - Set this to true to enable the cobuild feature.\n   * RUSH_COBUILD_CONTEXT_ID should always be specified as an environment variable with an non-empty string,\n   * otherwise the cobuild feature will be disabled.\n   */\n  "cobuildFeatureEnabled": true,\n\n  /**\n   * (Required) Choose where cobuild lock will be acquired.\n   *\n   * The lock provider is registered by the rush plugins.\n   * For example, @rushstack/rush-redis-cobuild-plugin registers the "redis" lock provider.\n   */\n  "cobuildLockProvider": "redis"\n}\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Run ",(0,r.kt)("inlineCode",{parentName:"p"},"rush update")," which should now install the ",(0,r.kt)("inlineCode",{parentName:"p"},"cobuild-plugin")," autoinstaller. This downloads its\nmanifest file:"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"common/autoinstallers/cobuild-plugin/rush-plugins/@rushstack/rush-redis-cobuild-plugin/rush-plugin-manifest.json")),(0,r.kt)("p",{parentName:"li"},"Commit this file to Git as well. (As part of the plugin system, this file caches important information so\nthat Rush can access it without having to install the plugin's NPM package.)"))),(0,r.kt)("h2",{id:"configuring-build-pipelines"},"Configuring build pipelines"),(0,r.kt)("p",null,"Each CI system has different ways of defining jobs. For this tutorial, we'll use a\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.github.com/en/actions/using-workflows/about-workflows"},"GitHub Actions workflow"),"\nsince it's included with the free plan for public projects."),(0,r.kt)("p",null,"Suppose our non-cobuild CI pipeline looks like this (with build cache writes enabled):"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},".github/workflows/ci-single.yml")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"name: ci-single.yml\non:\n  #push:\n  #  branches: ['main']\n  #pull_request:\n  #  branches: ['main']\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\njobs:\n  build:\n    name: build\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n\n      - name: Rush Install\n        run: node common/scripts/install-run-rush.js install\n\n      - name: Rush build (install-run-rush)\n        run: node common/scripts/install-run-rush.js build --verbose --timeline\n        env:\n          RUSH_BUILD_CACHE_WRITE_ALLOWED: 1\n          RUSH_BUILD_CACHE_CREDENTIAL: ${{ secrets.RUSH_BUILD_CACHE_CREDENTIAL }}\n")),(0,r.kt)("p",null,"Here's how we would convert that into a cobuild with 3 runners:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},".github/workflows/ci-cobuild.yml")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"name: ci-cobuild.yml\non:\n  #push:\n  #  branches: ['main']\n  #pull_request:\n  #  branches: ['main']\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\njobs:\n  build:\n    name: cobuild\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        runner_id: [runner1, runner2, runner3]\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 16\n\n      - name: Rush Install\n        run: node common/scripts/install-run-rush.js install\n\n      - name: Rush build (install-run-rush)\n        run: node common/scripts/install-run-rush.js build --verbose --timeline\n        env:\n          RUSH_BUILD_CACHE_WRITE_ALLOWED: 1\n          RUSH_BUILD_CACHE_CREDENTIAL: ${{ secrets.RUSH_BUILD_CACHE_CREDENTIAL }}\n          RUSH_COBUILD_CONTEXT_ID: ${{ github.run_id }}_${{ github.run_number }}_${{ github.run_attempt }}\n          RUSH_COBUILD_RUNNER_ID: ${{ matrix.runner_id }}\n          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"runner_id")," matrix causes the job to be run on 3 separate machines. The ",(0,r.kt)("inlineCode",{parentName:"p"},"REDIS_PASSWORD")," variable name\nis what we defined earlier in ",(0,r.kt)("strong",{parentName:"p"},"rush-redis-cobuild-plugin.json"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_CONTEXT_ID"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_RUNNER_ID")," variables are explained below."),(0,r.kt)("h2",{id:"cobuild-environment-variables-in-detail"},"Cobuild environment variables in detail"),(0,r.kt)("h3",{id:"rush_cobuild_context_id"},(0,r.kt)("inlineCode",{parentName:"h3"},"RUSH_COBUILD_CONTEXT_ID")),(0,r.kt)("p",null,"Cobuild runners must define this environment variable; without it, Rush will perform a regular build without\nany cobuild logic."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_CONTEXT_ID")," variable controls caching: Imagine that a pull request validation has failed\nbecause a project had errors. Without cobuilds, a project with errors is NOT saved to the build cache. If a\nperson goes to the GitHub website and clicks a button to ",(0,r.kt)("strong",{parentName:"p"},'"Re-run this job"'),", the successful projects will\nbe pulled from the cache, but that failed project will be forced to build again, which is good because maybe\nit was a transient failure."),(0,r.kt)("p",null,"Whereas with cobuilds, if a project has errors, we don't want the other two machines to try to build that project.\nThe error logs are saved to the build cache, and will be restored and printed by the other runners (to provide\na complete log on every machine). But if a person clicks ",(0,r.kt)("strong",{parentName:"p"},'"Re-run this job"'),", how do we force the failing\nprojects to get rebuild in that case? The ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_CONTEXT_ID")," identifier solves this, by getting added\nto the cache key to force a rebuild."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_CONTEXT_ID")," is specified differently for each system. It can be any string with these properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUSH_COBUILD_CONTEXT_ID")," must be the same across every machine for a given job"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RUSH_COBUILD_CONTEXT_ID"),' must be different each time the job is run, including reattempts of the same "run"'),(0,r.kt)("li",{parentName:"ul"},"It must be a short string, because it becomes part of a cache key")),(0,r.kt)("p",null,"Some examples:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"CI system"),(0,r.kt)("th",{parentName:"tr",align:null},"Suggested value for ",(0,r.kt)("inlineCode",{parentName:"th"},"RUSH_COBUILD_CONTEXT_ID")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/run-number?view=azure-devops&tabs=yaml"},"Azure DevOps")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"${{ Build.BuildNumber }}"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables"},"GitHub Actions")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"}," ${{ github.run_id }}_${{ github.run_number }}_${{ github.run_attempt }}"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://circleci.com/docs/variables/"},"CircleCI")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"${CIRCLE_WORKFLOW_ID}_${CIRCLE_WORKFLOW_JOB_ID}"))))),(0,r.kt)("h3",{id:"rush_cobuild_runner_id"},(0,r.kt)("inlineCode",{parentName:"h3"},"RUSH_COBUILD_RUNNER_ID")),(0,r.kt)("p",null,"This environment variable to uniquely identifies each machine. If this variable is not defined,\nRush will generate a random identifier on each run."),(0,r.kt)("p",null,"In the example, we specified it as ",(0,r.kt)("inlineCode",{parentName:"p"},"RUSH_COBUILD_RUNNER_ID: ${{ matrix.runner_id }}")," for readability."),(0,r.kt)("h2",{id:"technical-details"},"Technical details"),(0,r.kt)("h3",{id:"build-cache-correctness"},"Build cache correctness"),(0,r.kt)("p",null,"You will find that the cobuild feature increases the requirement that every project's output is accurately saved\nand restored by the cache. To see why, suppose that project ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," directly depends on project ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),". There are several\nways that an inaccurate cache might still produce a successful build:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Project ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"B")," are both cache misses, so no caching occurs. ",(0,r.kt)("strong",{parentName:"li"},"- OR -")),(0,r.kt)("li",{parentName:"ol"},"Project ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"B")," are both cache hits. ",(0,r.kt)("inlineCode",{parentName:"li"},"B")," does not get restored accurately. ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," would have failed to\ncompile, but didn't need to build ",(0,r.kt)("inlineCode",{parentName:"li"},"A"),". The final result of ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," is still correct. ",(0,r.kt)("strong",{parentName:"li"},"- OR -")),(0,r.kt)("li",{parentName:"ol"},"Only project ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," is a cache miss. ",(0,r.kt)("inlineCode",{parentName:"li"},"B")," does not get restored accurately, but the missing files are\nstill on disk from a previous build on the same machine. Thus ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," compiles without errors.")),(0,r.kt)("p",null,"These lucky situations are relatively common in non-cobuild scenarios, and if you're unlucky, the problem might\ngo away of you try again. The failure won't be noticed consistently until this happens:"),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Only project ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," is a cache miss. ",(0,r.kt)("inlineCode",{parentName:"li"},"B")," does not get restored accurately, and we started with a clean disk.")),(0,r.kt)("p",null,"Cobuilds greatly increase the likelihood of encountering #4, because their goal is to build cache misses\nthat depend on a cache hit. In short, after first enabling the cobuilds feature, you may need to spend some time\nfixing incorrect build cache configurations."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\ud83d\udc49 ",(0,r.kt)("strong",{parentName:"p"},"rush-audit-cache-plugin")),(0,r.kt)("p",{parentName:"blockquote"},"If you suspect that files are not getting accurately saved/restored by the Rush build cache,\ntry the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/rush-audit-cache-plugin"},"rush-audit-cache-plugin"),".\nIt detects such problems by monitoring file writes during a build operation. The file paths are then compared\nwith your cache configuration to produce a report of file paths that aren't being cached correctly.")),(0,r.kt)("h3",{id:"what-gets-stored-in-redis"},"What gets stored in Redis?"),(0,r.kt)("p",null,"The cobuild feature uses Redis for two main purposes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"A reentrant locking mechanism.")," The key corresponding to the lock is in the format of\n",(0,r.kt)("inlineCode",{parentName:"p"},"cobuild:lock:<context_id>:<cluster_id>"),", and the corresponding value is ",(0,r.kt)("inlineCode",{parentName:"p"},"<runner_id>"),".\nWhen setting the lock key, a 30-second expiration time is also set.\nThis ensures that the same runner can reacquire the lock when attempting to obtain it again,\nwhile also automatically releasing the lock if the runner does not respond for a certain period of time.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Track completed operations.")," The key corresponding to the completed state is in the format of\n",(0,r.kt)("inlineCode",{parentName:"p"},"cobuild:completed:<context_id>:<cache_id>"),", and the corresponding value is a string in a serialized form\nof the operation's execution result and the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"cache_id"),". Before attempting to acquire a lock,\na machine will first query this completion result information. If there is a completion result available,\nthe result is reused based on the parsed information."))),(0,r.kt)("h2",{id:"see-also"},"See also"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/pages/maintainer/build_cache"},"Enabling the build cache")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/pages/configs/environment_vars"},"Environment variables")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/pages/maintainer/using_rush_plugins"},"Using Rush plugins")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/pages/maintainer/autoinstallers"},"Autoinstallers"))))}m.isMDXComponent=!0}}]);